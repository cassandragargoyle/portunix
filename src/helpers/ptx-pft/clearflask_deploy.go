package main

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"
)

const (
	clearflaskComposeFile = "docker-compose.yaml"
	clearflaskEnvFile     = ".env"
	clearflaskProjectName = "portunix-clearflask"
)

// checkClearFlaskKernelCompatibility checks if the kernel version is compatible with ClearFlask
// ClearFlask uses JDK 11 which has a known bug with cgroups v2 on Linux kernels 6.12+
func checkClearFlaskKernelCompatibility() (compatible bool, warning string) {
	// Only relevant on Linux
	if _, err := os.Stat("/proc/version"); os.IsNotExist(err) {
		return true, ""
	}

	file, err := os.Open("/proc/version")
	if err != nil {
		return true, ""
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	if scanner.Scan() {
		line := scanner.Text()
		// Extract kernel version from "Linux version X.Y.Z..."
		parts := strings.Fields(line)
		if len(parts) >= 3 && parts[0] == "Linux" && parts[1] == "version" {
			version := parts[2]
			// Parse major.minor version
			versionParts := strings.Split(version, ".")
			if len(versionParts) >= 2 {
				major, err1 := strconv.Atoi(versionParts[0])
				minor, err2 := strconv.Atoi(versionParts[1])
				if err1 == nil && err2 == nil {
					// Kernels 6.12+ have stricter cgroups v2 that breaks JDK 11
					if major > 6 || (major == 6 && minor >= 12) {
						return false, fmt.Sprintf(`
╔══════════════════════════════════════════════════════════════════════════════╗
║  ⚠️  WARNING: KERNEL COMPATIBILITY ISSUE                                     ║
╠══════════════════════════════════════════════════════════════════════════════╣
║  Your kernel version (%d.%d) uses cgroups v2 which is incompatible with     ║
║  ClearFlask's JDK 11. The server will likely crash with:                     ║
║                                                                              ║
║    NullPointerException at CgroupV2Subsystem.getInstance                     ║
║                                                                              ║
║  This is an upstream ClearFlask issue requiring JDK 17+ upgrade.             ║
║  See: https://github.com/clearflask/clearflask                               ║
║                                                                              ║
║  Workarounds:                                                                ║
║    1. Use external ClearFlask instance (cloud/older server)                  ║
║    2. Use Fider instead (./ptx-pft deploy fider)                             ║
╚══════════════════════════════════════════════════════════════════════════════╝
`, major, minor)
					}
				}
			}
		}
	}

	return true, ""
}

// getClearFlaskDeployDir returns the directory where ClearFlask compose files are stored
func getClearFlaskDeployDir() (string, error) {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return "", fmt.Errorf("failed to get home directory: %w", err)
	}

	deployDir := filepath.Join(homeDir, ".portunix", "pft", "clearflask")
	if err := os.MkdirAll(deployDir, 0755); err != nil {
		return "", fmt.Errorf("failed to create deploy directory: %w", err)
	}

	return deployDir, nil
}

// writeClearFlaskComposeFile generates and writes docker-compose.yaml for ClearFlask
func writeClearFlaskComposeFile(deployDir string) (string, error) {
	pkg, err := loadPackageDefinition("clearflask")
	if err != nil {
		return "", err
	}

	yamlData, err := generateComposeYAML(pkg)
	if err != nil {
		return "", fmt.Errorf("failed to generate compose YAML: %w", err)
	}

	composePath := filepath.Join(deployDir, clearflaskComposeFile)
	if err := os.WriteFile(composePath, yamlData, 0644); err != nil {
		return "", fmt.Errorf("failed to write compose file: %w", err)
	}

	return composePath, nil
}

// writeClearFlaskEnvFile writes environment variables for ClearFlask docker-compose
func writeClearFlaskEnvFile(deployDir string, config *Config) (string, error) {
	envPath := filepath.Join(deployDir, clearflaskEnvFile)

	// Check if env file already exists (reuse secrets)
	existingEnv := make(map[string]string)
	if data, err := os.ReadFile(envPath); err == nil {
		for _, line := range strings.Split(string(data), "\n") {
			if parts := strings.SplitN(line, "=", 2); len(parts) == 2 {
				existingEnv[parts[0]] = parts[1]
			}
		}
	}

	// Generate or reuse secrets
	dbRootPassword := existingEnv["CLEARFLASK_DB_ROOT_PASSWORD"]
	if dbRootPassword == "" {
		dbRootPassword = generateSecret(16)
	}

	dbPassword := existingEnv["CLEARFLASK_DB_PASSWORD"]
	if dbPassword == "" {
		dbPassword = generateSecret(16)
	}

	// Determine host URL
	hostURL := config.GetEndpoint()
	if hostURL == "" {
		hostURL = "http://localhost:3100"
	}

	env := fmt.Sprintf(`# ClearFlask environment configuration
# Generated by portunix pft deploy

# MariaDB Database
CLEARFLASK_DB_ROOT_PASSWORD=%s
CLEARFLASK_DB_PASSWORD=%s

# Host URL
CLEARFLASK_HOST=%s
`, dbRootPassword, dbPassword, hostURL)

	if err := os.WriteFile(envPath, []byte(env), 0600); err != nil {
		return "", fmt.Errorf("failed to write env file: %w", err)
	}

	return envPath, nil
}

// runClearFlaskContainerCompose executes portunix container compose command for ClearFlask
func runClearFlaskContainerCompose(deployDir string, args ...string) error {
	portunixPath, err := findPortunix()
	if err != nil {
		return err
	}

	fullArgs := []string{
		"container", "compose",
		"-f", filepath.Join(deployDir, clearflaskComposeFile),
		"--env-file", filepath.Join(deployDir, clearflaskEnvFile),
		"-p", clearflaskProjectName,
	}
	fullArgs = append(fullArgs, args...)

	cmd := exec.Command(portunixPath, fullArgs...)
	cmd.Dir = deployDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	return cmd.Run()
}

// DeployClearFlask deploys ClearFlask using Docker Compose
func DeployClearFlask(config *Config) (*DeployResult, error) {
	result := &DeployResult{}

	// Check kernel compatibility and warn user
	if compatible, warning := checkClearFlaskKernelCompatibility(); !compatible {
		fmt.Println(warning)
		fmt.Print("Do you want to continue anyway? [y/N]: ")
		var response string
		fmt.Scanln(&response)
		if response != "y" && response != "Y" {
			return nil, fmt.Errorf("deployment cancelled due to kernel compatibility issue")
		}
	}

	// Get deploy directory
	deployDir, err := getClearFlaskDeployDir()
	if err != nil {
		return nil, err
	}

	// Write compose file (generated from JSON)
	composePath, err := writeClearFlaskComposeFile(deployDir)
	if err != nil {
		return nil, err
	}
	result.ComposeFile = composePath

	// Write env file
	envPath, err := writeClearFlaskEnvFile(deployDir, config)
	if err != nil {
		return nil, err
	}
	result.EnvFile = envPath

	fmt.Println("Starting ClearFlask deployment...")
	fmt.Printf("  Compose file: %s\n", composePath)
	fmt.Printf("  Environment: %s\n", envPath)
	fmt.Println()
	fmt.Println("Note: ClearFlask requires ~2GB RAM and may take 1-2 minutes to start.")
	fmt.Println()

	// Pull images
	fmt.Println("Pulling container images...")
	if err := runClearFlaskContainerCompose(deployDir, "pull"); err != nil {
		return nil, fmt.Errorf("failed to pull images: %w", err)
	}

	// Start services
	fmt.Println()
	fmt.Println("Starting services...")
	if err := runClearFlaskContainerCompose(deployDir, "up", "-d"); err != nil {
		return nil, fmt.Errorf("failed to start services: %w", err)
	}

	// Determine URL
	baseURL := config.GetEndpoint()
	if baseURL == "" {
		baseURL = "http://localhost:3100"
	}

	result.Success = true
	result.URL = baseURL
	result.Message = fmt.Sprintf(`ClearFlask deployed successfully!

Access ClearFlask at: %s
LocalStack S3 at:     http://localhost:4566

Note: First startup may take 1-2 minutes for database initialization and Elasticsearch indexing.

Services:
  - MariaDB:              Running
  - Elasticsearch:        Running
  - LocalStack (S3):      Running
  - ClearFlask Server:    Running
  - ClearFlask Connect:   Running

Resource usage: ~2GB RAM minimum`, baseURL)

	return result, nil
}

// GetClearFlaskStatus returns the status of ClearFlask deployment
func GetClearFlaskStatus() (string, error) {
	deployDir, err := getClearFlaskDeployDir()
	if err != nil {
		return "", err
	}

	// Check if compose file exists
	composePath := filepath.Join(deployDir, clearflaskComposeFile)
	if _, err := os.Stat(composePath); os.IsNotExist(err) {
		return "not_deployed", nil
	}

	// Check container status using portunix container compose
	portunixPath, err := findPortunix()
	if err != nil {
		return "unknown", err
	}

	cmd := exec.Command(portunixPath,
		"container", "compose",
		"-f", composePath,
		"-p", clearflaskProjectName,
		"ps", "--format", "{{.State}}",
	)
	output, err := cmd.Output()
	if err != nil {
		return "error", nil
	}

	states := strings.TrimSpace(string(output))
	if states == "" {
		return "stopped", nil
	}

	// Check if all containers are running
	for _, state := range strings.Split(states, "\n") {
		if state != "running" {
			return "partial", nil
		}
	}

	return "running", nil
}

// GetClearFlaskContainerInfo returns detailed container information for ClearFlask
func GetClearFlaskContainerInfo() (string, error) {
	deployDir, err := getClearFlaskDeployDir()
	if err != nil {
		return "", err
	}

	composePath := filepath.Join(deployDir, clearflaskComposeFile)
	if _, err := os.Stat(composePath); os.IsNotExist(err) {
		return "ClearFlask is not deployed.", nil
	}

	portunixPath, err := findPortunix()
	if err != nil {
		return "", err
	}

	cmd := exec.Command(portunixPath,
		"container", "compose",
		"-f", composePath,
		"-p", clearflaskProjectName,
		"ps",
	)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return string(output), nil
	}

	return string(output), nil
}

// DestroyClearFlask removes the ClearFlask deployment
func DestroyClearFlask(removeVolumes bool) error {
	deployDir, err := getClearFlaskDeployDir()
	if err != nil {
		return err
	}

	composePath := filepath.Join(deployDir, clearflaskComposeFile)
	if _, err := os.Stat(composePath); os.IsNotExist(err) {
		return fmt.Errorf("ClearFlask is not deployed")
	}

	fmt.Println("Stopping and removing ClearFlask containers...")

	args := []string{"down"}
	if removeVolumes {
		args = append(args, "-v")
		fmt.Println("  (including volumes - this will delete all data)")
	}

	if err := runClearFlaskContainerCompose(deployDir, args...); err != nil {
		return fmt.Errorf("failed to destroy deployment: %w", err)
	}

	fmt.Println("ClearFlask deployment removed successfully.")

	// Optionally remove deploy directory
	if removeVolumes {
		if err := os.RemoveAll(deployDir); err != nil {
			fmt.Printf("Warning: could not remove deploy directory: %v\n", err)
		}
	}

	return nil
}

// DeployClearFlaskInstance deploys a named ClearFlask instance on specified port
func DeployClearFlaskInstance(instanceName string, port int, config *Config) (*DeployResult, error) {
	result := &DeployResult{}

	// Get instance-specific deploy directory
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return nil, fmt.Errorf("failed to get home directory: %w", err)
	}

	deployDir := filepath.Join(homeDir, ".portunix", "pft", "clearflask-"+instanceName)
	if err := os.MkdirAll(deployDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create deploy directory: %w", err)
	}

	projectName := fmt.Sprintf("portunix-clearflask-%s", instanceName)

	// Generate compose file with custom port
	composeContent := generateClearFlaskInstanceComposeYAML(instanceName, port)
	composePath := filepath.Join(deployDir, clearflaskComposeFile)
	if err := os.WriteFile(composePath, []byte(composeContent), 0644); err != nil {
		return nil, fmt.Errorf("failed to write compose file: %w", err)
	}
	result.ComposeFile = composePath

	// Write env file with instance-specific settings
	envPath, err := writeClearFlaskInstanceEnvFile(deployDir, instanceName, port, config)
	if err != nil {
		return nil, err
	}
	result.EnvFile = envPath

	fmt.Printf("Starting ClearFlask (%s) deployment on port %d...\n", instanceName, port)
	fmt.Println("Note: ClearFlask requires ~2GB RAM and may take 1-2 minutes to start.")
	fmt.Println()

	// Pull images
	fmt.Println("Pulling container images...")
	if err := runClearFlaskInstanceContainerCompose(deployDir, projectName, "pull"); err != nil {
		return nil, fmt.Errorf("failed to pull images: %w", err)
	}

	// Start services
	fmt.Println()
	fmt.Println("Starting services...")
	if err := runClearFlaskInstanceContainerCompose(deployDir, projectName, "up", "-d"); err != nil {
		return nil, fmt.Errorf("failed to start services: %w", err)
	}

	baseURL := fmt.Sprintf("http://localhost:%d", port)
	localstackPort := port + 50

	result.Success = true
	result.URL = baseURL
	result.Message = fmt.Sprintf("ClearFlask (%s) deployed on port %d\nLocalStack S3: http://localhost:%d", instanceName, port, localstackPort)

	return result, nil
}

// generateClearFlaskInstanceComposeYAML generates docker-compose.yaml for a specific ClearFlask instance
func generateClearFlaskInstanceComposeYAML(instanceName string, port int) string {
	localstackPort := port + 50 // LocalStack port

	return fmt.Sprintf(`services:
  mariadb:
    image: mariadb:10.5
    container_name: clearflask-%s-db
    environment:
      MYSQL_ROOT_PASSWORD: ${CLEARFLASK_DB_ROOT_PASSWORD}
      MYSQL_DATABASE: clearflask
      MYSQL_USER: clearflask
      MYSQL_PASSWORD: ${CLEARFLASK_DB_PASSWORD}
    volumes:
      - clearflask-%s-db:/var/lib/mysql
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 10
    restart: unless-stopped

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:7.10.0
    container_name: clearflask-%s-es
    environment:
      - discovery.type=single-node
      - ES_JAVA_OPTS=-Xms512m -Xmx512m
      - xpack.security.enabled=false
    volumes:
      - clearflask-%s-es:/usr/share/elasticsearch/data
    healthcheck:
      test: ["CMD-SHELL", "curl -s http://localhost:9200/_cluster/health | grep -vq '\"status\":\"red\"'"]
      interval: 30s
      timeout: 10s
      retries: 10
    restart: unless-stopped

  localstack:
    image: localstack/localstack:0.14.3
    container_name: clearflask-%s-s3
    ports:
      - "%d:4566"
    environment:
      SERVICES: s3
      DEFAULT_REGION: us-east-1
      DATA_DIR: /tmp/localstack/data
    volumes:
      - clearflask-%s-s3:/tmp/localstack
    healthcheck:
      test: ["CMD-SHELL", "curl -s http://localhost:4566/_localstack/health | grep -q 's3'"]
      interval: 30s
      timeout: 10s
      retries: 5
    restart: unless-stopped

  clearflask-server:
    image: ghcr.io/clearflask/clearflask-server:latest
    container_name: clearflask-%s-server
    environment:
      CLEARFLASK_ENVIRONMENT: PRODUCTION_SELF_HOST
      CLEARFLASK_DB_HOST: mariadb
      CLEARFLASK_DB_PORT: "3306"
      CLEARFLASK_DB_USER: clearflask
      CLEARFLASK_DB_PASS: ${CLEARFLASK_DB_PASSWORD}
      CLEARFLASK_DB_DATABASE: clearflask
      CLEARFLASK_ES_HOST: elasticsearch
      CLEARFLASK_ES_PORT: "9200"
      CLEARFLASK_S3_ENDPOINT: http://localstack:4566
      CLEARFLASK_S3_REGION: us-east-1
      AWS_ACCESS_KEY_ID: test
      AWS_SECRET_ACCESS_KEY: test
    depends_on:
      mariadb:
        condition: service_healthy
      elasticsearch:
        condition: service_healthy
      localstack:
        condition: service_healthy
    restart: unless-stopped

  clearflask-connect:
    image: ghcr.io/clearflask/clearflask-connect:latest
    container_name: clearflask-%s-connect
    ports:
      - "%d:9080"
    environment:
      CLEARFLASK_SERVER_HOST: clearflask-server
    depends_on:
      clearflask-server:
        condition: service_started
    restart: unless-stopped

volumes:
  clearflask-%s-db:
  clearflask-%s-es:
  clearflask-%s-s3:
`, instanceName, instanceName, instanceName, instanceName, instanceName,
		localstackPort, instanceName, instanceName, instanceName, port,
		instanceName, instanceName, instanceName)
}

// writeClearFlaskInstanceEnvFile writes environment file for a specific ClearFlask instance
func writeClearFlaskInstanceEnvFile(deployDir, instanceName string, port int, config *Config) (string, error) {
	envPath := filepath.Join(deployDir, clearflaskEnvFile)

	// Check if env file already exists (reuse secrets)
	existingEnv := make(map[string]string)
	if data, err := os.ReadFile(envPath); err == nil {
		for _, line := range strings.Split(string(data), "\n") {
			if parts := strings.SplitN(line, "=", 2); len(parts) == 2 {
				existingEnv[parts[0]] = parts[1]
			}
		}
	}

	// Generate or reuse secrets
	dbRootPassword := existingEnv["CLEARFLASK_DB_ROOT_PASSWORD"]
	if dbRootPassword == "" {
		dbRootPassword = generateSecret(16)
	}

	dbPassword := existingEnv["CLEARFLASK_DB_PASSWORD"]
	if dbPassword == "" {
		dbPassword = generateSecret(16)
	}

	baseURL := fmt.Sprintf("http://localhost:%d", port)

	env := fmt.Sprintf(`# ClearFlask %s environment configuration
# Generated by portunix pft deploy

CLEARFLASK_DB_ROOT_PASSWORD=%s
CLEARFLASK_DB_PASSWORD=%s
CLEARFLASK_HOST=%s
`, instanceName, dbRootPassword, dbPassword, baseURL)

	if err := os.WriteFile(envPath, []byte(env), 0600); err != nil {
		return "", fmt.Errorf("failed to write env file: %w", err)
	}

	return envPath, nil
}

// runClearFlaskInstanceContainerCompose executes portunix container compose for a specific ClearFlask instance
func runClearFlaskInstanceContainerCompose(deployDir, projectName string, args ...string) error {
	portunixPath, err := findPortunix()
	if err != nil {
		return err
	}

	fullArgs := []string{
		"container", "compose",
		"-f", filepath.Join(deployDir, clearflaskComposeFile),
		"--env-file", filepath.Join(deployDir, clearflaskEnvFile),
		"-p", projectName,
	}
	fullArgs = append(fullArgs, args...)

	cmd := exec.Command(portunixPath, fullArgs...)
	cmd.Dir = deployDir
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	return cmd.Run()
}
